From Wikipedia, the free encyclopedia Jump to: navigation, search "Object-oriented" redirects here. For other meanings of object-oriented, see Object-orientation. "Object oriented language" redirects here. It is not to be confused with Object-based language. "Object-oriented programming language" redirects here. For a list of object-oriented programming languages, see List of object-oriented programming languages. This article may be in need of reorganization to comply with Wikipedia's layout guidelines. Please help by editing the article to make improvements to the overall structure. (November 2012) Programming paradigms Action Agent-oriented Aspect-oriented Automata-based Concurrent computing Relativistic programming Data-driven Declarative (contrast: Imperative) Constraint Dataflow Flow-based Cell-oriented (spreadsheets) Reactive Functional Functional logic Logic Abductive logic Answer set Constraint logic Functional logic Inductive logic Relational End-user programming Event-driven Service-oriented Time-driven Expression-oriented Feature-oriented Function-level (contrast: Value-level) Generic Imperative (contrast: Declarative) Procedural Language-oriented Natural language programming Discipline-specific Domain-specific Grammar-oriented Dialecting Intentional Metaprogramming Automatic Reflective Attribute-oriented Homoiconic Template Policy-based Non-structured (contrast: Structured) Array Nondeterministic Parallel computing Process-oriented Point-free style Concatenative Semantic Structured (contrast: Non-structured) Block-structured Modular (contrast: Monolithic) Object-oriented (OOP) By separation of concerns: Aspect-oriented Role-oriented Subject-oriented Class-based Prototype-based Recursive Value-level (contrast: Function-level) Probabilistic Concept v t e Object-oriented programming (OOP) is a programming paradigm based on the concept of "objects", which are data structures that contain data, in the form of fields, often known as attributes; and code, in the form of procedures, often known as methods. A distinguishing feature of objects is that an object's procedures can access and often modify the data fields of the object with which they are associated (objects have a notion of "this"). In object-oriented programming, computer programs are designed by making them out of objects that interact with one another.[1][2] There is significant diversity in object-oriented programming, but most popular languages are class-based, meaning that objects are instances of classes, which typically also determines their type. Many of the most widely used programming languages are multi-paradigm programming languages that support object-oriented programming to a greater or lesser degree, typically in combination with imperative, procedural programming. Significant object-oriented languages include C++, Objective-C, Smalltalk, Delphi, Java, C#, Perl, Python, Ruby and PHP. Contents 1 Overview 2 History 3 Fundamental features and concepts 3.1 Decoupling 4 Additional features 5 Formal semantics 6 OOP languages 6.1 OOP in dynamic languages 7 Design patterns 7.1 Inheritance and behavioral subtyping 7.2 Gang of Four design patterns 7.3 Object-orientation and databases 7.4 Real-world modeling and relationships 7.5 OOP and control flow 7.6 Responsibility- vs. data-driven design 8 Criticism 9 See also 10 References 11 Further reading 12 External links Overview[edit] The neutrality of this section is disputed. Relevant discussion may be found on the talk page. Please do not remove this message until the dispute is resolved. (January 2014) Object-oriented programming attempts to provide a model for programming based on objects.[3] Object-oriented programming integrates code and data using the concept of an "object". An object is an abstract data type with the addition of polymorphism and inheritance. An object has both state (data) and behavior (code). Objects sometimes correspond to things found in the real world. For example, a graphics program may have objects such as "circle," "square," "menu." An online shopping system will have objects such as "shopping cart," "customer," and "product." The shopping system will support behaviors such as "place order," "make payment," and "offer discount." Objects are designed in class hierarchies. For example, with the shopping system there might be high level classes such as "electronics product," "kitchen product," and "book." There may be further refinements for example under "electronic products": "CD Player," "DVD player," etc. These classes and subclasses correspond to sets and subsets in mathematical logic. Rather than utilizing database tables and programming subroutines, the developer utilizes objects the user may be more familiar with: objects from their application domain.[4] Object orientation uses encapsulation and information hiding. Object-orientation essentially merges abstract data types with structured programming and divides systems into modular objects which own their own data and are responsible for their own behavior. This feature is known as encapsulation. With encapsulation, the data for two objects are divided so that changes to one object cannot affect the other. Note that all this relies on the various languages being used appropriately, which, of course, is never certain. Object-orientation is not a software silver bullet.[5] The object-oriented approach encourages the programmer to place data where it is not directly accessible by the rest of the system. Instead, the data is accessed by calling specially written functions, called methods, which are bundled with the data. These act as the intermediaries for retrieving or modifying the data they control. The programming construct that combines data with a set of methods for accessing and managing that data is called an object. The practice of using subroutines to examine or modify certain kinds of data was also used in non-OOP modular programming, well before the widespread use of object-oriented programming. Defining software as modular components that support inheritance is meant to make it easy both to re-use existing components and to extend components as needed by defining new subclasses with specialized behaviors. This goal of being easy to both maintain and reuse is known in the object-oriented paradigm as the "open/closed principle." A module is open if it supports extension (e.g. can easily modify behavior, add new properties, provide default values, etc.). A module is closed if it has a well defined stable interface that all other modules must use and that limits the interaction and potential errors that can be introduced into one module by changes in another.[6] History[edit] Terminology invoking "objects" and "oriented" in the modern sense of object-oriented programming made its first appearance at MIT in the late 1950s and early 1960s. In the environment of the artificial intelligence group, as early as 1960, "object" could refer to identified items (LISP atoms) with properties (attributes);[7][8] Alan Kay was later to cite a detailed understanding of LISP internals as a strong influence on his thinking in 1966.[9] Another early MIT example was Sketchpad created by Ivan Sutherland in 1960–61; in the glossary of the 1963 technical report based on his dissertation about Sketchpad, Sutherland defined notions of "object" and "instance" (with the class concept covered by "master" or "definition"), albeit specialized to graphical interaction.[10] Also, an MIT ALGOL version, AED-0, linked data structures ("plexes", in that dialect) directly with procedures, prefiguring what were later termed "messages", "methods", and "member functions".[11][12] The formal programming concept of objects was introduced in the 1960s in Simula 67, a major revision of Simula I, a programming language designed for discrete event simulation, created by Ole-Johan Dahl and Kristen Nygaard of the Norwegian Computing Center in Oslo.[13] Simula 67 was influenced by SIMSCRIPT and C.A.R. "Tony" Hoare's proposed "record classes".[11][14] Simula introduced the notion of classes and instances or objects (as well as subclasses, virtual methods, coroutines, and discrete event simulation) as part of an explicit programming paradigm. The language also used automatic garbage collection that had been invented earlier for the functional programming language Lisp. Simula was used for physical modeling, such as models to study and improve the movement of ships and their content through cargo ports. The ideas of Simula 67 influenced many later languages, including Smalltalk, derivatives of LISP (CLOS), Object Pascal, and C++. The Smalltalk language, which was developed at Xerox PARC (by Alan Kay and others) in the 1970s, introduced the term object-oriented programming to represent the pervasive use of objects and messages as the basis for computation. Smalltalk creators were influenced by the ideas introduced in Simula 67, but Smalltalk was designed to be a fully dynamic system in which classes could be created and modified dynamically rather than statically as in Simula 67.[15] Smalltalk and with it OOP were introduced to a wider audience by the August 1981 issue of Byte Magazine. In the 1970s, Kay's Smalltalk work had influenced the Lisp community to incorporate object-based techniques that were introduced to developers via the Lisp machine. Experimentation with various extensions to Lisp (such as LOOPS and Flavors introducing multiple inheritance and mixins) eventually led to the Common Lisp Object System, which integrates functional programming and object-oriented programming and allows extension via a Meta-object protocol. In the 1980s, there were a few attempts to design processor architectures that included hardware support for objects in memory but these were not successful. Examples include the Intel iAPX 432 and the Linn Smart Rekursiv. In 1985, Bertrand Meyer produced the first design of the Eiffel language. Focused on software quality, Eiffel is among the purely object-oriented languages, but differs in the sense that the language itself is not only a programming language, but a notation supporting the entire software lifecycle. Meyer described the Eiffel software development method, based on a small number of key ideas from software engineering and computer science, in Object-Oriented Software Construction. Essential to the quality focus of Eiffel is Meyer's reliability mechanism, Design by Contract, which is an integral part of both the method and language. Object-oriented programming developed as the dominant programming methodology in the early and mid 1990s when programming languages supporting the techniques became widely available. These included Visual FoxPro 3.0,[16][17][18] C++[citation needed], and Delphi[citation needed]. Its dominance was further enhanced by the rising popularity of graphical user interfaces, which rely heavily upon object-oriented programming techniques. An example of a closely related dynamic GUI library and OOP language can be found in the Cocoa frameworks on Mac OS X, written in Objective-C, an object-oriented, dynamic messaging extension to C based on Smalltalk. OOP toolkits also enhanced the popularity of event-driven programming (although this concept is not limited to OOP). At ETH Zürich, Niklaus Wirth and his colleagues had also been investigating such topics as data abstraction and modular programming (although this had been in common use in the 1960s or earlier). Modula-2 (1978) included both, and their succeeding design, Oberon, included a distinctive approach to object orientation, classes, and such. Object-oriented features have been added to many previously existing languages, including Ada, BASIC, Fortran, Pascal, and COBOL. Adding these features to languages that were not initially designed for them often led to problems with compatibility and maintainability of code. More recently, a number of languages have emerged that are primarily object-oriented, but that are also compatible with procedural methodology. Two such languages are Python and Ruby. Probably the most commercially-important recent object-oriented languages are Java, developed by Sun Microsystems, as well as C# and Visual Basic.NET (VB.NET), both designed for Microsoft's .NET platform. Each of these two frameworks shows, in its own way, the benefit of using OOP by creating an abstraction from implementation. VB.NET and C# support cross-language inheritance, allowing classes defined in one language to subclass classes defined in the other language. Developers usually compile Java to bytecode, allowing Java to run on any operating system for which a Java virtual machine is available. Fundamental features and concepts [edit] See also: List of object-oriented programming terms A survey by Deborah J. Armstrong of nearly 40 years of computing literature identified a number of fundamental concepts found in the large majority of definitions of OOP.[19] Not all of these concepts appear in all object-oriented programming languages. For example, object-oriented programming that uses classes is sometimes called class-based programming, while prototype-based programming does not typically use classes. As a result, a significantly different yet analogous terminology is used to define the concepts of object and instance. Benjamin C. Pierce and some other researchers view any attempt to distill OOP to a minimal set of features as futile. He nonetheless identifies fundamental features that support the OOP programming style in most object-oriented languages:[20] Dynamic dispatch – when a method is invoked on an object, the object itself determines what code gets executed by looking up the method at run time in a table associated with the object. This feature distinguishes an object from an abstract data type (or module), which has a fixed (static) implementation of the operations for all instances. It is a programming methodology that gives modular component development while at the same time being very efficient. Encapsulation (or multi-methods, in which case the state is kept separate) Subtype polymorphism Object inheritance (or delegation) Open recursion – a special variable (syntactically it may be a keyword), usually called this or self, that allows a method body to invoke another method body of the same object. This variable is late-bound; it allows a method defined in one class to invoke another method that is defined later, in some subclass thereof. Similarly, in his 2003 book, Concepts in programming languages, John C. Mitchell identifies four main features: dynamic dispatch, abstraction, subtype polymorphism, and inheritance.[21] Michael Lee Scott in Programming Language Pragmatics considers only encapsulation, inheritance, and dynamic dispatch.[22] Additional concepts used in object-oriented programming include: Classes of objects (object constructors) Instances of classes (objects, which have been constructed via a class) Methods which act on the attached objects. Message passing Abstraction Decoupling[edit] Decoupling refers to careful controls that separate code modules from particular use cases, which increases code re-usability. A common use of decoupling is to mainly decouple the encapsulation (see bridge pattern and adapter pattern) – for example, using a method interface that an encapsulated object must satisfy, as opposed to using the object's class. Additional features[edit] Encapsulation enforces modularity Encapsulation refers to the creation of self-contained modules that bind processing functions to the data. These user-defined data types are called "classes", and one instance of a class is an "object". For example, in a payroll system, a class could be Manager, and Pat and Jan could be two instances (two objects) of the Manager class. Encapsulation ensures good code modularity, which keeps routines separate and less prone to conflict with each other. Inheritance passes "knowledge" down Classes are created in hierarchies, and inheritance lets the structure and methods in one class pass down the hierarchy. That means less programming is required when adding functions to complex systems. If a step is added at the bottom of a hierarchy, only the processing and data associated with that unique step must be added. Everything else above that step is inherited. The ability to reuse existing objects is considered a major advantage of object technology. Polymorphism takes any shape Object-oriented programming lets programmers create procedures for objects whose exact type is not known until runtime. For example, a screen cursor may change its shape from an arrow to a line depending on the program mode. The routine to move the cursor on screen in response to mouse movement can be written for "cursor", and polymorphism lets that cursor take simulating system behaviour. Formal semantics[edit] See also: Formal semantics of programming languages Objects are the run-time entities in an object-oriented system. They may represent a person, a place, a bank account, a table of data, or any item that the program has to handle. There have been several attempts at formalizing the concepts used in object-oriented programming. The following concepts and constructs have been used as interpretations of OOP concepts: co algebraic data types[23] abstract data types (which have existential types) allow the definition of modules but these do not support dynamic dispatch recursive types encapsulated state inheritance records are basis for understanding objects if function literals can be stored in fields (like in functional programming languages), but the actual calculi need be considerably more complex to incorporate essential features of OOP. Several extensions of System F<: that deal with mutable objects have been studied;[24] these allow both subtype polymorphism and parametric polymorphism (generics) Attempts to find a consensus definition or theory behind objects have not proven very successful (however, see Abadi & Cardelli, A Theory of Objects[24] for formal definitions of many OOP concepts and constructs), and often diverge widely. For example, some definitions focus on mental activities, and some on program structuring. One of the simpler definitions is that OOP is the act of using "map" data structures or arrays that can contain functions and pointers to other maps, all with some syntactic and scoping sugar on top. Inheritance can be performed by cloning the maps (sometimes called "prototyping"). OOP languages[edit] This section does not cite any references or sources. Please help improve this section by adding citations to reliable sources. Unsourced material may be challenged and removed. (August 2009) See also: List of object-oriented programming languages Simula (1967) is generally accepted as the first language with the primary features of an object-oriented language. It was created for making simulation programs, in which what came to be called objects were the most important information representation. Smalltalk (1972 to 1980) is arguably the canonical example, and the one with which much of the theory of object-oriented programming was developed. Concerning the degree of object orientation, the following distinctions can be made: Languages called "pure" OO languages, because everything in them is treated consistently as an object, from primitives such as characters and punctuation, all the way up to whole classes, prototypes, blocks, modules, etc. They were designed specifically to facilitate, even enforce, OO methods. Examples: Eiffel, Emerald,[25] JADE, Obix, Ruby, Python, Scala, Smalltalk, Self. Languages designed mainly for OO programming, but with some procedural elements. Examples: Delphi/Object Pascal, C++, Java, C#, VB.NET. Languages that are historically procedural languages, but have been extended with some OO features. Examples: Pascal, Visual Basic (derived from BASIC), MATLAB, Fortran, Perl, COBOL 2002, PHP, ABAP, Ada 95. Languages with most of the features of objects (classes, methods, inheritance), but in a distinctly original form. Examples: Oberon (Oberon-1 or Oberon-2). Languages with abstract data type support, but not all features of object-orientation, sometimes called object-based languages. Examples: Modula-2, Pliant, CLU. Chameleon languages that support multiple paradigms, including OO. Tcl stands out among these for TclOO, a hybrid object system that supports both prototype-based programming and class-based OO. OOP in dynamic languages[edit] In recent years, object-oriented programming has become especially popular in dynamic programming languages. Python, Ruby and Groovy are dynamic languages built on OOP principles, while Perl and PHP have been adding object-oriented features since Perl 5 and PHP 4, and ColdFusion since version 6. The Document Object Model of HTML, XHTML, and XML documents on the Internet has bindings to the popular JavaScript/ECMAScript language. JavaScript is perhaps the best known prototype-based programming language, which employs cloning from prototypes rather than inheriting from a class (contrast to class-based programming). Another scripting language that takes this approach is Lua. Before ActionScript 2.0 (a partial superset of the ECMA-262 R3, otherwise known as ECMAScript) only a prototype-based object model was supported. Design patterns[edit] Challenges of object-oriented design are addressed by several methodologies. Most common is known as the design patterns codified by Gamma et al.. More broadly, the term "design patterns" can be used to refer to any general, repeatable solution to a commonly occurring problem in software design. Some of these commonly occurring problems have implications and solutions particular to object-oriented development. Inheritance and behavioral subtyping[edit] See also: Object-oriented design It is intuitive to assume that inheritance creates a semantic "is a" relationship, and thus to infer that objects instantiated from subclasses can always be safely used instead of those instantiated from the superclass. This intuition is unfortunately false in most OOP languages, in particular in all those that allow mutable objects. Subtype polymorphism as enforced by the type checker in OOP languages (with mutable objects) cannot guarantee behavioral subtyping in any context. Behavioral subtyping is undecidable in general, so it cannot be implemented by a program (compiler). Class or object hierarchies must be carefully designed, considering possible incorrect uses that cannot be detected syntactically. This issue is known as the Liskov substitution principle. Gang of Four design patterns[edit] Main article: Design pattern (computer science) Design Patterns: Elements of Reusable Object-Oriented Software is an influential book published in 1995 by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides, often referred to humorously as the "Gang of Four". Along with exploring the capabilities and pitfalls of object-oriented programming, it describes 23 common programming problems and patterns for solving them. As of April 2007, the book was in its 36th printing. The book describes the following patterns: Creational patterns (5): Factory method pattern, Abstract factory pattern, Singleton pattern, Builder pattern, Prototype pattern Structural patterns (7): Adapter pattern, Bridge pattern, Composite pattern, Decorator pattern, Facade pattern, Flyweight pattern, Proxy pattern Behavioral patterns (11): Chain-of-responsibility pattern, Command pattern, Interpreter pattern, Iterator pattern, Mediator pattern, Memento pattern, Observer pattern, State pattern, Strategy pattern, Template method pattern, Visitor pattern Object-orientation and databases[edit] Main articles: Object-relational impedance mismatch, Object-relational mapping and Object database Both object-oriented programming and relational database management systems (RDBMSs) are extremely common in software today[update]. Since relational databases don't store objects directly (though some RDBMSs have object-oriented features to approximate this), there is a general need to bridge the two worlds. The problem of bridging object-oriented programming accesses and data patterns with relational databases is known as object-relational impedance mismatch. There are a number of approaches to cope with this problem, but no general solution without downsides.[26] One of the most common approaches is object-relational mapping, as found in libraries like Java Data Objects and Ruby on Rails' ActiveRecord. There are also object databases that can be used to replace RDBMSs, but these have not been as technically and commercially successful as RDBMSs. Real-world modeling and relationships[edit] OOP can be used to associate real-world objects and processes with digital counterparts. However, not everyone agrees that OOP facilitates direct real-world mapping (see Criticism section) or that real-world mapping is even a worthy goal; Bertrand Meyer argues in Object-Oriented Software Construction[27] that a program is not a model of the world but a model of some part of the world; "Reality is a cousin twice removed". At the same time, some principal limitations of OOP had been noted.[28] For example, the circle-ellipse problem is difficult to handle using OOP's concept of inheritance. However, Niklaus Wirth (who popularized the adage now known as Wirth's law: "Software is getting slower more rapidly than hardware becomes faster") said of OOP in his paper, "Good Ideas through the Looking Glass", "This paradigm closely reflects the structure of systems 'in the real world', and it is therefore well suited to model complex systems with complex behaviours" (contrast KISS principle). Steve Yegge and others noted that natural languages lack the OOP approach of strictly prioritizing things (objects/nouns) before actions (methods/verbs).[29] This problem may cause OOP to suffer more convoluted solutions than procedural programming.[30] OOP and control flow[edit] OOP was developed to increase the reusability and maintainability of source code.[31] Transparent representation of the control flow had no priority and was meant to be handled by a compiler. With the increasing relevance of parallel hardware and multithreaded coding, developing transparent control flow becomes more important, something hard to achieve with OOP.[32][33][34][35] Responsibility- vs. data-driven design[edit] Responsibility-driven design defines classes in terms of a contract, that is, a class should be defined around a responsibility and the information that it shares. This is contrasted by Wirfs-Brock and Wilkerson with data-driven design, where classes are defined around the data-structures that must be held. The authors hold that responsibility-driven design is preferable. Criticism[edit] The OOP paradigm has been criticised for a number of reasons, including not meeting its stated goals of reusability and modularity,[36][37] and for overemphasizing one aspect of software design and modeling (data/objects) at the expense of other important aspects (computation/algorithms).[38][39] Luca Cardelli has claimed that OOP code is "intrinsically less efficient" than procedural code, that OOP can take longer to compile, and that OOP languages have "extremely poor modularity properties with respect to class extension and modification", and tend to be extremely complex.[36] The latter point is reiterated by Joe Armstrong, the principal inventor of Erlang, who is quoted as saying:[37] The problem with object-oriented languages is they've got all this implicit environment that they carry around with them. You wanted a banana but what you got was a gorilla holding the banana and the entire jungle. A study by Potok et al. has shown no significant difference in productivity between OOP and procedural approaches.[40] Christopher J. Date stated that critical comparison of OOP to other technologies, relational in particular, is difficult because of lack of an agreed-upon and rigorous definition of OOP;[41] however, Date and Darwen have proposed a theoretical foundation on OOP that uses OOP as a kind of customizable type system to support RDBMS.[42] In an article Lawrence Krubner claimed that compared to other languages (lisps, functional languages, etc) OOP languages have no unique strengths, and inflict a heavy burden of unneeded complexity.[43] Alexander Stepanov compares object orientation unfavourably to multimethods:[38] I find OOP technically unsound. It attempts to decompose the world in terms of interfaces that vary on a single type. To deal with the real problems you need multisorted algebras — families of interfaces that span multiple types. I find OOP philosophically unsound. It claims that everything is an object. Even if it is true it is not very interesting — saying that everything is an object is saying nothing at all. Paul Graham has suggested that OOP's popularity within large companies is due to "large (and frequently changing) groups of mediocre programmers." According to Graham, the discipline imposed by OOP prevents any one programmer from "doing too much damage."[44] Steve Yegge noted that, as opposed to functional programming:[45] Object Oriented Programming puts the Nouns first and foremost. Why would you go to such lengths to put one part of speech on a pedestal? Why should one kind of concept take precedence over another? It's not as if OOP has suddenly made verbs less important in the way we actually think. It's a strangely skewed perspective. Rich Hickey, creator of Clojure, described object systems as overly simplistic models of the real world. He emphasized the inability of OOP to model time properly, which is getting increasingly problematic as software systems become more concurrent.[39] Eric S. Raymond, a Unix programmer and open-source software advocate, has been critical of claims that present object-oriented programming as the "One True Solution," and has written that object-oriented programming languages tend to encourage thickly-layered programs that destroy transparency.[46] Raymond contrasts this to the approach taken with Unix and the C programming language.[47] See also[edit] This "see also" section may contain an excessive number of suggestions. Please ensure that only the most relevant suggestions are given and that they are not red links, and consider integrating suggestions into the article itself. (April 2014) Computer programming portal Aspect-oriented programming CADES Comparison of programming languages (object-oriented programming) Comparison of programming paradigms Component-based software engineering Concurrent object-oriented programming Constructor (object-oriented programming) Constructor overloading CORBA DCOM Design by contract GRASP IDEF4 Interface-based programming Interface description language Jeroo Lepus3 Modular programming Object association Object database Object modeling language Object-oriented analysis and design Object-relational impedance mismatch (and The Third Manifesto) Object-relational mapping Procedural programming Refactoring SOLID Structured programming Visual FoxPro ZZT-oop References[edit] ^ Kindler, E.; Krivy, I. (2011). "Object-Oriented Simulation of systems with sophisticated control". International Journal of General Systems. pp. 313–343.  ^ Lewis, John; Loftus, William (2008). Java Software Solutions Foundations of Programming Design 6th ed. Pearson Education Inc. ISBN 0-321-53205-8. , section 1.6 "Object-Oriented Programming" ^ Booch, Grady (1986). Software Engineering with Ada. Addison Wesley. p. 220. ISBN 978-0805306088. Perhaps the greatest strength of an object-oriented approach to development is that it offers a mechanism that captures a model of the real world.  ^ Jacobsen, Ivar; Magnus Christerson; Patrik Jonsson; Gunnar Overgaard (1992). Object Oriented Software Engineering. Addison-Wesley ACM Press. pp. 43–69. ISBN 0-201-54435-0.  ^ Brooks, Fred P. (April 1987). "No Silver Bullet — Essence and Accidents of Software Engineering". IEEE Computer 20 (4): 10–19.  ^ Meyer, Bertrand (1988). Object-Oriented Software Construction. Cambridge: Prentice Hall International Series in Computer Science. p. 23. ISBN 0-13-629049-3.  ^ McCarthy, J.; Brayton, R.; Edwards, D.; Fox, P.; Hodes, L.; Luckham, D.; Maling, K.; Park, D.; Russell, S. (March 1960). "LISP I Programmers Manual". Boston, Massachusetts: Artificial Intelligence Group, M.I.T. Computation Center and Research Laboratory. p. 88f. In the local M.I.T. patois, association lists [of atomic symbols] are also referred to as "property lists", and atomic symbols are sometimes called "objects".  ^ McCarthy, John; Abrahams, Paul W.; Edwards, Daniel J.; Hart, swapnil d.; Levin, Michael I. (1962). LISP 1.5 Programmer's Manual. MIT Press. p. 105. ISBN 0-262-13011-4. Object — a synonym for atomic symbol  ^ "Dr. Alan Kay on the Meaning of "Object-Oriented Programming"". 2003. Retrieved 11 February 2010.  ^ Sutherland, I. E. (30 January 1963). "Sketchpad: A Man-Machine Graphical Communication System" (PDF). Technical Report No. 296, Lincoln Laboratory, Massachusetts Institute of Technology via Defense Technical Information Center (stinet.dtic.mil). Retrieved 3 November 2007.  ^ a b The Development of the Simula Languages, Kristen Nygaard, Ole-Johan Dahl, p.254 Uni-kl.ac.at ^ Ross, Doug. "The first software engineering language". LCS/AI Lab Timeline:. MIT Computer Science and Artificial Intelligence Laboratory. Retrieved 13 May 2010.  ^ Holmevik, Jan Rune (1994). "Compiling Simula: A historical study of technological genesis". IEEE Annals of the History of Computing 16 (4): 25–37. doi:10.1109/85.329756. Retrieved 12 May 2010.  ^ Hoare, C. A. (Nov 1965). "Record Handling". ALGOL Bulletin (21): 39–69. doi:10.1145/1061032.1061041.  ^ Kay, Alan. "The Early History of Smalltalk". Retrieved 13 September 2007.  ^ 1995 (June) Visual FoxPro 3.0, FoxPro evolves from a procedural language to an object-oriented language. Visual FoxPro 3.0 introduces a database container, seamless client/server capabilities, support for ActiveX technologies, and OLE Automation and null support. Summary of Fox releases ^ FoxPro History web site: Foxprohistory.org ^ 1995 Reviewers Guide to Visual FoxPro 3.0: DFpug.de ^ Armstrong, The Quarks of Object-Oriented Development. In descending order of popularity, the "quarks" are: Inheritance, Object, Class, Encapsulation, Method, Message Passing, Polymorphism, Abstraction ^ Pierce, Benjamin (2002). Types and Programming Languages. MIT Press. ISBN 0-262-16209-1. , section 18.1 "What is Object-Oriented Programming?" ^ John C. Mitchell, Concepts in programming languages, Cambridge University Press, 2003, ISBN 0-521-78098-5, p.278 ^ Michael Lee Scott, Programming language pragmatics, Edition 2, Morgan Kaufmann, 2006, ISBN 0-12-633951-1, p. 470 vikas ^ Poll, Erik. "Subtyping and Inheritance for Categorical Datatypes". Retrieved 5 June 2011.  ^ a b Abadi, Martin; Cardelli, Luca (1996). A Theory of Objects. Springer-Verlag New York, Inc. ISBN 0-387-94775-2. Retrieved 21 April 2010.  ^ "The Emerald Programming Language". 2011-02-26.  ^ Neward, Ted (26 June 2006). "The Vietnam of Computer Science". Interoperability Happens. Retrieved 2 June 2010.  ^ Meyer, Second Edition, p. 230 ^ M.Trofimov, OOOP - The Third "O" Solution: Open OOP. First Class, OMG, 1993, Vol. 3, issue 3, p.14. ^ Yegge, Steve (30 March 2006). "Execution in the Kingdom of Nouns". steve-yegge.blogspot.com. Retrieved 3 July 2010.  ^ Boronczyk, Timothy (11 June 2009). "What's Wrong with OOP". zaemis.blogspot.com. Retrieved 3 July 2010.  ^ Ambler, Scott (1 January 1998). "A Realistic Look at Object-Oriented Reuse". www.drdobbs.com. Retrieved 4 July 2010.  ^ Shelly, Asaf (22 August 2008). "Flaws of Object Oriented Modeling". Intel Software Network. Retrieved 4 July 2010.  ^ James, Justin (1 October 2007). "Multithreading is a verb not a noun". techrepublic.com. Retrieved 4 July 2010.  ^ Shelly, Asaf (22 August 2008). "HOW TO: Multicore Programming (Multiprocessing) Visual C++ Class Design Guidelines, Member Functions". support.microsoft.com. Retrieved 4 July 2010.  ^ Robert Harper (17 April 2011). "Some thoughts on teaching FP". Existential Type Blog. Retrieved 5 December 2011.  ^ a b Cardelli, Luca (1996). "Bad Engineering Properties of Object-Oriented Languages". ACM Comput. Surv. (ACM) 28 (4es): 150. doi:10.1145/242224.242415. ISSN 0360-0300. Retrieved 21 April 2010.  ^ a b Armstrong, Joe. In Coders at Work: Reflections on the Craft of Programming. Peter Seibel, ed. Codersatwork.com, Accessed 13 November 2009. ^ a b Stepanov, Alexander. "STLport: An Interview with A. Stepanov". Retrieved 21 April 2010.  ^ a b Rich Hickey, JVM Languages Summit 2009 keynote, Are We There Yet? November 2009. ^ Potok, Thomas; Mladen Vouk; Andy Rindos (1999). "Productivity Analysis of Object-Oriented Software Developed in a Commercial Environment". Software – Practice and Experience 29 (10): 833–847. doi:10.1002/(SICI)1097-024X(199908)29:10<833::AID-SPE258>3.0.CO;2-P. Retrieved 21 April 2010.  ^ C. J. Date, Introduction to Database Systems, 6th-ed., Page 650 ^ C. J. Date, Hugh Darwen. Foundation for Future Database Systems: The Third Manifesto (2nd Edition) ^ Krubner, Lawrence. "Object Oriented Programming is an expensive disaster which must end". smashcompany.com. Retrieved 14 October 2014.  ^ Graham, Paul. "Why ARC isn't especially Object-Oriented.". PaulGraham.com. Retrieved 13 November 2009.  ^ Stevey's Blog Rants ^ Eric S. Raymond (2003). "The Art of Unix Programming: Unix and Object-Oriented Languages". Retrieved 2014-08-06.  ^ Eric S. Raymond (2003). "The Art of Unix Programming: Unix and Object-Oriented Languages". Retrieved 2014-08-06.  Further reading[edit] Abadi, Martin; Luca Cardelli (1998). A Theory of Objects. Springer Verlag. ISBN 0-387-94775-2.  Abelson, Harold; Gerald Jay Sussman, (1997). Structure and Interpretation of Computer Programs. MIT Press. ISBN 0-262-01153-0.  Cite uses deprecated parameters (help) Armstrong, Deborah J. (February 2006). "The Quarks of Object-Oriented Development". Communications of the ACM 49 (2): 123–128. doi:10.1145/1113034.1113040. ISSN 0001-0782. Retrieved 8 August 2006.  Booch, Grady (1997). Object-Oriented Analysis and Design with Applications. Addison-Wesley. ISBN 0-8053-5340-2.  Eeles, Peter; Oliver Sims (1998). Building Business Objects. John Wiley & Sons. ISBN 0-471-19176-0.  Gamma, Erich; Richard Helm, Ralph Johnson, John Vlissides (1995). Design Patterns: Elements of Reusable Object Oriented Software. Addison-Wesley. ISBN 0-201-63361-2.  Cite uses deprecated parameters (help) Harmon, Paul; William Morrissey (1996). The Object Technology Casebook - Lessons from Award-Winning Business Applications. John Wiley & Sons. ISBN 0-471-14717-6.  Jacobson, Ivar (1992). Object-Oriented Software Engineering: A Use Case-Driven Approach. Addison-Wesley. ISBN 0-201-54435-0.  Kay, Alan. The Early History of Smalltalk.  Meyer, Bertrand (1997). Object-Oriented Software Construction. Prentice Hall. ISBN 0-13-629155-4.  Pecinovsky, Rudolf (2013). OOP - Learn Object Oriented Thinking & Programming. Bruckner Publishing. ISBN 978-80-904661-8-0.  Rumbaugh, James; Michael Blaha; William Premerlani; Frederick Eddy; William Lorensen (1991). Object-Oriented Modeling and Design. Prentice Hall. ISBN 0-13-629841-9.  Schach, Stephen (2006). Object-Oriented and Classical Software Engineering, Seventh Edition. McGraw-Hill. ISBN 0-07-319126-4.  Schreiner, Axel-Tobias (1993). Object oriented programming with ANSI-C. Hanser. ISBN 3-446-17426-5. hdl:1850/8544.  Taylor, David A. (1992). Object-Oriented Information Systems - Planning and Implementation. John Wiley & Sons. ISBN 0-471-54364-0.  Weisfeld, Matt (2009). The Object-Oriented Thought Process, Third Edition. Addison-Wesley. ISBN 0-672-33016-4.  External links[edit] Wikiquote has quotations related to: Object-orientation Wikiversity has learning materials about Object-oriented programming at Topic:Object-Oriented Programming Wikibooks has a book on the topic of: Object Oriented Programming Object-oriented programming at DMOZ Introduction to Object Oriented Programming Concepts (OOP) and More by L.W.C. Nirosh Discussion about the flaws of OOD OOP Concepts (Java Tutorials) Intel blog - killing OOP intelblog v t e Types of programming languages Array Aspect-oriented Class-based Concatenative Concurrent Data-structured Dataflow Declarative Domain-specific Dynamic Esoteric Event-driven Extensible Functional Imperative Logic Macro Metaprogramming Multi-paradigm Object-based Object-oriented Pipeline Procedural Prototype-based Reflective Rule-based Scripting Synchronous Templating Assembly Compiled Interpreted Machine Low-level High-level Very high-level First generation Second generation Third generation Fourth generation Fifth generation Non-English-based Off-side rule Visual v t e Software engineering Fields Computer programming Software requirements Software deployment Software design Software maintenance Software testing Systems analysis Formal methods Concepts Data modeling Enterprise architecture Functional specification Modeling language Orthogonality Programming paradigm Software Software architecture Software development methodology Software development process Software quality Software quality assurance Software archaeology Structured analysis Orientations Agile Aspect-oriented Object orientation Ontology Service orientation SDLC Models Developmental Agile EUP Executable UML Incremental model Iterative model Prototype model RAD UP Other SPICE CMMI Data model ER model Function model Information model Metamodeling Object model Systems model View model Languages IDEF UML SysML Software engineers Kent Beck Grady Booch Fred Brooks Barry Boehm Ward Cunningham Tom DeMarco Edsger W. Dijkstra Martin Fowler C. A. R. Hoare Watts Humphrey Michael A. Jackson Ivar Jacobson Stephen J. Mellor Bertrand Meyer David Parnas Winston W. Royce James Rumbaugh Niklaus Wirth Edward Yourdon Victor Basili Related fields Computer science Computer engineering Project management Systems engineering Category Commons Retrieved from "http://en.wikipedia.org/w/index.php?title=Object-oriented_programming&oldid=637155160" Categories: Object-oriented programming Programming paradigms Hidden categories: CS1 maint: display-authors Wikipedia articles needing reorganization from November 2012 NPOV disputes from January 2014 All NPOV disputes All articles with unsourced statements Articles with unsourced statements from April 2007 Articles with unsourced statements from February 2010 Articles needing additional references from August 2009 All articles needing additional references Articles containing potentially dated statements from 2006 All articles containing potentially dated statements Articles with excessive see also sections from April 2014 Pages containing cite templates with deprecated parameters Articles with DMOZ links Use dmy dates from September 2010